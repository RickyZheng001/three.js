<!DOCTYPE html>
<html lang="en">
	<head>
		<title>诺普信息技术</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <meta http-equiv="Access-Control-Allow-Origin" content="*">
		<link href="https://fonts.googleapis.com/css?family=Electrolize:400" rel="stylesheet" type="text/css">
		<script async="" src="//www.google-analytics.com/analytics.js"></script>
		<script type="text/javascript" src="./js/jquery-ui-1.10.4.custom/js/jquery-1.10.2.js"></script>
		<script type="text/javascript" src="./js/jquery-ui-1.10.4.custom/js/jquery-ui-1.10.4.custom.min.js"></script>
		<link rel="stylesheet" href="./js/jquery-ui-1.10.4.custom/css_smoothness/jquery-ui.css">
		<link rel="stylesheet" href="style.css" type="text/css" media="screen">
		<script type="text/javascript" src="gui.js"></script>

		<script type="text/javascript" src="../dat.gui-master/build/dat.gui.js"></script>
		<script src="../build/three.js"></script>
		<script src="../build/three.module.js"></script>
		<script src="../dat.gui-master/tests/jquery.js"></script>
		<script src="./utils/LoadGui.js"></script>
		<script src="../examples/js/controls/OrbitControls.js"></script>
		<script src="../examples/js/QuickHull.js"></script>
		<script src="../examples/js/geometries/ConvexGeometry.js"></script>
		<script src="../examples/js/Detector.js"></script>
		<script src="../examples/js/libs/stats.min.js"></script>
		<script src="../examples/js/loaders/STLLoader.js"></script>
		<script src="../examples/js/loaders/OBJLoader.js"></script>
		<script src="../examples/js/loaders/PLYLoader.js"></script>
	</head>

	<body>
		<div id="canvas">
			<table width="100%" height = "811" border="0">
				<tr>
					<td width="100%"><div id="gameCanvas" width="1280px" height="811"></div></td>
				</tr>
			</table>
		</div>

		<script>

			function AddAxisArrowHelper(scene)
			{
                var Xdir = new THREE.Vector3(1,0,0);
                var Ydir = new THREE.Vector3(0,1,0);
                var Zdir = new THREE.Vector3(0,0,1);

				//确定原点，箭头长度，和箭头颜色，三个箭头同一设置
                var origin = new THREE.Vector3(0,0,0);
                var length = 200;
                var color = 0xffff00;

				//建立三个方向上箭头辅助
                var YarrowHelper = new THREE.ArrowHelper(Ydir,origin,length,0xff0000);
                var ZarrowHelper = new THREE.ArrowHelper(Zdir,origin,length,0x0000ff);
                var XarrowHelper = new THREE.ArrowHelper(Xdir,origin,length,0x00ff00);
				//把箭头辅助加入 场景
                scene.add(YarrowHelper);
                scene.add(ZarrowHelper);
                scene.add(XarrowHelper);
			}

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var modelArray = new Array();
			var camera, scene, renderer;
			var orbitControls;
			var modelNode;
			var xzPlane,xyPlane,yzPlane;
			var axisHelper;
			var lastModelColor;
            var menuObj = {};
            var reflectMaterial;

			var mouseX = 0, mouseY = 0;

			//var width = 800;
			//var height = 600;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
            //var windowHalfX = width / 2;
           // var windowHalfY = height / 2;

            function onClickUpdateModel(geometry)
            {
                var material = null;
                if (geometry.hasColors) {
                    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });
                }
                else
                {
                    material = new THREE.MeshPhongMaterial( { color: 0xAAAAAA, specular: 0x111111, shininess: 200 } );
                }

                var mesh = new THREE.Mesh( geometry, material );

                mesh.position.set( 0, 0, 0);
                mesh.rotation.set( - Math.PI / 2, 0, 0 );
                mesh.scale.set( 1,1,1 );

                mesh.castShadow = true;
                mesh.receiveShadow = true;

                //object.position.y = - 95;
                scene.add( mesh );
                modelArray.push(mesh);

                modelNode = mesh;
            }
            function removeAllSceneModel()
			{
			    var i = 0;
			    for(i = 0; i < modelArray.length; i++)
				{
				    scene.remove(modelArray[i]);
				}

				modelArray = new Array();
			}
            function onCallBack(response)
			{
                var onProgress = function ( xhr ) {

                };

                var onError = function ( xhr ) {
                };

                removeAllSceneModel();

                var jsonObj = eval('(' + response + ')');
                var modelFileList = jsonObj.ModelFileList;
                var pdfFile = jsonObj.PdfList[0];
                var pdfCtrl = document.getElementById( 'pdfCtrl' );
                pdfCtrl.src = 'http://localhost:1337/' + pdfFile;

                var i = 0;
                for(i = 0; i < modelFileList.length; i++)
				{
				    var requestURL = 'http://localhost:1337' + modelFileList[i].URL;
                    var modelColor = modelFileList[i].DefaultColor;
					//var a = "#" + modelColor;
					//menuObj["模型颜色" + (i + 1)] = "#" + modelColor;

                    var loader = new THREE.STLLoader();
                    loader.load(requestURL, function ( geometry ){
                        onClickUpdateModel(geometry);
                    },onProgress,onError);
				}
			}

			init();
			animate();

			function init() {

				container = document.getElementById( 'gameCanvas' );
				//container.width = 800;
				//container.height = 600;
				//document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, 800 / 600, 1, 2000 );
				camera.position.z = 250;

				// scene

				scene = new THREE.Scene();

				var ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );

				var pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( pointLight );
				scene.add( camera );

                axisHelper = new THREE.AxisHelper(200);
                axisHelper.material.depthTest = false;
                scene.add(axisHelper);

                var planeGeometry = new THREE.PlaneGeometry(60,40,10,10);
                //平面材质，基本材质是渲染不出阴影的，下面的材质可以，仅仅指定颜色
                var planeMaterial = new THREE.MeshLambertMaterial({color:0xff00dd});
                planeMaterial.wireframe = true;
                //以给定的尺寸和材质构建一个平面
                xzPlane = new THREE.Mesh(planeGeometry,planeMaterial);
                //指定平面的旋转角度，方便观察
                xzPlane.rotation.x = -0.5 * Math.PI;
                //平面的位置
                xzPlane.position.x = 0;
                xzPlane.position.y = 0;
                xzPlane.position.z = 0;
                //平面加入场景
                scene.add(xzPlane);

                planeMaterial = new THREE.MeshLambertMaterial({color:0x00ffdd});
                planeMaterial.wireframe = true;
                yzPlane = new THREE.Mesh(planeGeometry,planeMaterial);
                yzPlane.rotation.y = -0.5 * Math.PI;
                yzPlane.position.x = 0;
                yzPlane.position.y = 0;
                yzPlane.position.z = 0;
                scene.add(yzPlane);

                planeMaterial = new THREE.MeshLambertMaterial({color:0xffdd00});
                planeMaterial.wireframe = true;
                xyPlane = new THREE.Mesh(planeGeometry,planeMaterial);
                //指定平面的旋转角度，方便观察
                xyPlane.rotation.z = -0.5 * Math.PI;
                //平面的位置
                xyPlane.position.x = 0;
                xyPlane.position.y = 0;
                xyPlane.position.z = 0;
                //平面加入场景
                scene.add(xyPlane);

                //AddAxisArrowHelper(scene);

				// texture
                var path = "../examples/textures/cube/skybox/";
                var urls = [
                    path + "px.jpg", path + "nx.jpg",
                    path + "py.jpg", path + "ny.jpg",
                    path + "pz.jpg", path + "nz.jpg"
                ];

                textureCube = new THREE.CubeTextureLoader().load( urls );
                reflectMaterial = new THREE.MeshPhongMaterial( { color: 0xe4e4e4, envMap: textureCube, side: THREE.DoubleSide } );

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

				// model

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};

				var onError = function ( xhr ) {
				};

				//var loader = new THREE.OBJLoader( manager );
                //var loader = new THREE.PLYLoader();
                var material = new THREE.MeshPhongMaterial( { color: 0xAAAAAA, specular: 0x111111, shininess: 200 } );
                var loader = new THREE.STLLoader();
				//loader.load( 'obj/male02/male02.obj', function ( object ) {
                loader.load( 'obj/test/test123.stl', function ( geometry ){
                //loader.load( 'http://localhost:1337', function ( geometry ) {
                    onClickUpdateModel(geometry);
				}, onProgress, onError );

				//

				renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
				});
                this.renderer.setClearColor(0x000000, 0);
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( 1280,811 );
				container.appendChild( renderer.domElement );

                orbitControls = new THREE.OrbitControls( camera, renderer.domElement );
                orbitControls.minDistance = 50;
                orbitControls.maxDistance = 1000;
                orbitControls.maxPolarAngle = Math.PI;

				//document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				//

				//window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

			    var width = 800;
			    var height = 600;
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();
			}

			function update()
			{
			    var i = 0;

                for(i = 0; i < modelArray.length; i++)
                {
                    modelArray[i].material = reflectMaterial;
                }

                axisHelper.visible = menuObj["显示坐标轴"];
                xzPlane.visible = menuObj["显示xz平面"];
                xyPlane.visible = menuObj["显示xy平面"];
                yzPlane.visible = menuObj["显示yz平面"];
			}
			function render() {


			    update();
				//camera.position.x += ( mouseX - camera.position.x ) * .05;
				//camera.position.y += ( - mouseY - camera.position.y ) * .05;

				//camera.lookAt( scene.position );
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>
